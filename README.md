# Stack Processor Emulator

<div id="problemtext">

### Problem Statement

The Gedanum state has decided to conquer space. In the first stage, it plans to send a number of probes that will search for planets suitable for colonization. The probes must be intelligent and energy-efficient, so a new processor is needed to control them. The commission of Experts Technology Interstellar was commissioned to design it. After many hours of hard work and numerous flashes of genius, the Stack Translator Of Symbols, model AaD5, was created. It still requires a lot of work to start mass production, but in order not to waste time, you were commissioned to write an emulator of this processor. Thanks to it, the creation of probe control systems can begin much faster.

The processor has a program memory, an instruction pointer, and a stack. Program memory stores the program. A program is a sequence of instructions, and each instruction is one character. The instruction pointer stores the number of the instruction that will be executed next, and increments by one after each execution (for most instructions). The processor terminates when the instruction pointer points beyond the last instruction in the program. The first instruction is numbered 0.

The stack stores data for calculations. The stack elements are lists containing zero or more characters (digits, letters, and other symbols). If the list contains only digits and at most one '-' (minus) character at the end, we say that such a list contains a number. The youngest digit of the number is stored in the first position of the list, so the number -1234 is stored as a list `4321-`.

It can be assumed that all programs will be correct, i.e., there will be no situations not foreseen in the instruction list.

</div>

### Instruction Set

| Symbol | Name          | Behavior                                                         |
| ------ | ------------- | ---------------------------------------------------------------- |
| `'`    | apostrophe    | Push an empty list on the stack                                  |
| `,`    | comma         | Pop a list from the stack                                        |
| `:`    | colon         | Duplicate the list on the top of the stack                       |
| `;`    | semicolon     | Swap the top two lists on the stack                              |
| `@`    | at            | Pop number A; copy the top list into the A-th position (0 = top) |
| `.`    | dot           | Read a char from stdin; prepend to the top list                  |
| `>`    | greater than  | Write first char of top list to stdout; pop that list            |
| `!`    | exclamation   | Logical negation: empty or "0" → "1", else → "0"                 |
| `<`    | less than     | Pop A, B; push 1 if B < A, else 0                                |
| `=`    | equal         | Pop A, B; push 1 if B = A, else 0                                |
| `~`    | tilde         | Push the current instruction pointer (IP) value                  |
| `?`    | question mark | Pop T, W; if W ≠ empty and ≠ "0", set IP = T (no increment)      |
| `-`    | minus         | Toggle trailing '-' on number-list (negation)                    |
| `^`    | caret         | Absolute value: remove trailing '-' if present                   |
| `$`    | dollar        | Split: detach first char from top list and push it as new list   |
| `#`    | hash          | Pop list A; append it to the end of the top list                 |
| `+`    | plus          | Pop A, B; push A + B                                             |
| `&`    | ampersand     | Print stack: each line `n: list` with 0 = top                    |
| `[`    | bracket open  | Pop list A; push ASCII code of its first char                    |
| `]`    | bracket close | Pop number A; push list containing char with ASCII A             |
| other  | literal       | Append this character to the top list                            |

### Input

* **Line 1:** Program (string of instructions, no whitespace).

* **Line 2:** Characters for the program's standard input (no whitespace).

* Constraints:

  * Program length ≤ 20,000 instructions
  * Input length ≤ 20,000 characters

### Output

All output generated by `>` and `&` instructions in program order.

### Rules and Scoring

* Do **not** use STL containers (except for program/input storage) or arrays (only allowed for program/input).
* Only **one** loop (`for`/`while`/`do...while`) is allowed, **everywhere else** use recursion.

Tests are grouped; each group adds more instructions:

| Groups | Instructions Covered                              | Score |
| ------ | ------------------------------------------------- | ----- |
| 1–3    | `' , : ; @ &` + literals (int-range numbers only) | 12.5% |
| 4–6    | `' , : ; @ &` + literals                          | 12.5% |
| 7–9    | Add `. > - ^`                                     | 12.5% |
| 10–12  | Add `[ ] $ #`                                     | 12.5% |
| 13–16  | Add `< = ! ~ ?`                                   | 25%   |
| 17–19  | Add `+`                                           | 25%   |

> **Note:** On Visual Studio, adjust stack reserve to ≥ 10 MB if needed (default 1 MB).

### Examples

**Input**

```
'123'-456&+&
```

**Output**

```
1: 321
0: 654-
0: 333-
```

**Input**

```
'...&$&
123
```

**Output**

```
0: 321
1: 21
0: 3
```
